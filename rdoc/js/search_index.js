var search_data = {"index":{"searchIndex":["locuser","addressformatter","addressedlocation","city","configuration","country","county","engine","locality","location","state","streetaddress","address()","city()","city=()","config()","configure()","contains?()","contains?()","contains?()","contains?()","country()","country=()","county()","county=()","do_initialize()","format()","full_address()","get_entity_type()","get_entity_type()","get_entity_type()","get_entity_type()","get_entity_type()","get_entity_type()","includetypeinname?()","includetypeinname?()","latitude()","longitude()","new()","new()","primary_key()","reset()","set_address()","state()","state=()","street1()","street1=()","street2()","street2=()","typeifiedname()","use_country()","use_country=()","valid_parent_types()","valid_parent_types()","valid_parent_types()","valid_parent_types()","valid_parent_types()","zip()","zip=()","readme"],"longSearchIndex":["locuser","locuser::addressformatter","locuser::addressedlocation","locuser::city","locuser::configuration","locuser::country","locuser::county","locuser::engine","locuser::locality","locuser::location","locuser::state","locuser::streetaddress","locuser::streetaddress#address()","locuser::streetaddress#city()","locuser::streetaddress#city=()","locuser::configuration::config()","locuser::configuration::configure()","locuser::city#contains?()","locuser::country#contains?()","locuser::locality#contains?()","locuser::state#contains?()","locuser::streetaddress#country()","locuser::streetaddress#country=()","locuser::streetaddress#county()","locuser::streetaddress#county=()","locuser::streetaddress#do_initialize()","locuser::addressformatter#format()","locuser::streetaddress#full_address()","locuser::addressedlocation#get_entity_type()","locuser::city#get_entity_type()","locuser::country#get_entity_type()","locuser::county#get_entity_type()","locuser::locality#get_entity_type()","locuser::state#get_entity_type()","locuser::county#includetypeinname?()","locuser::locality#includetypeinname?()","locuser::location#latitude()","locuser::location#longitude()","locuser::addressformatter::new()","locuser::configuration::new()","locuser::locality::primary_key()","locuser::configuration::reset()","locuser::streetaddress#set_address()","locuser::streetaddress#state()","locuser::streetaddress#state=()","locuser::streetaddress#street1()","locuser::streetaddress#street1=()","locuser::streetaddress#street2()","locuser::streetaddress#street2=()","locuser::locality#typeifiedname()","locuser::addressformatter#use_country()","locuser::addressformatter#use_country=()","locuser::addressedlocation#valid_parent_types()","locuser::city#valid_parent_types()","locuser::country#valid_parent_types()","locuser::county#valid_parent_types()","locuser::state#valid_parent_types()","locuser::streetaddress#zip()","locuser::streetaddress#zip=()",""],"info":[["Locuser","","Locuser.html","","<p>locuser/address_formatter.rb\n<p>taxonomite_configuration.rb\n\n<pre>hold configuration parameters for the library</pre>\n"],["Locuser::AddressFormatter","","Locuser/AddressFormatter.html","","<p>Class to handle formatting of addresses from a hash containing a specific\npattern There is a default …\n"],["Locuser::AddressedLocation","","Locuser/AddressedLocation.html","","<p>Class which encloses a Locuser::StreetAddress and pulls it into persistent\nstorage, as well as wrapping …\n"],["Locuser::City","","Locuser/City.html","",""],["Locuser::Configuration","","Locuser/Configuration.html","",""],["Locuser::Country","","Locuser/Country.html","","<p>Represents a country as a Locality. Has no particular location. Can accept\nStates, and Locations as children. …\n"],["Locuser::County","","Locuser/County.html","",""],["Locuser::Engine","","Locuser/Engine.html","",""],["Locuser::Locality","","Locuser/Locality.html","",""],["Locuser::Location","","Locuser/Location.html","","<p>Describes a specific location - this is represented as a\nlatitude/longitude. Subclasses may contain addresses …\n"],["Locuser::State","","Locuser/State.html","",""],["Locuser::StreetAddress","","Locuser/StreetAddress.html","","<p>Class to handle street addresses - this is not necessarily stored as a part\nof a Mongoid document, but …\n"],["address","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-address","(h1=nil)","<p>get a particular address component. Generally :street1, :street2, :city,\n:state, :zip, :country are supported. …\n"],["city","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-city","()",""],["city=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-city-3D","(val)",""],["config","Locuser::Configuration","Locuser/Configuration.html#method-c-config","()",""],["configure","Locuser::Configuration","Locuser/Configuration.html#method-c-configure","()",""],["contains?","Locuser::City","Locuser/City.html#method-i-contains-3F","(loc)","<p>Determines whether a location lies within the city. @param\n[Locuser::StreetAddress, #read] loc location …\n"],["contains?","Locuser::Country","Locuser/Country.html#method-i-contains-3F","(loc)","<p>Determines whether a location lies within the country. @param\n[Locuser::StreetAddress, #read] loc location …\n"],["contains?","Locuser::Locality","Locuser/Locality.html#method-i-contains-3F","(loc)","<p>does this locality contain a location? base class method returns false\n@param [Locuser::Location, #read …\n"],["contains?","Locuser::State","Locuser/State.html#method-i-contains-3F","(loc)","<p>Determines whether a location lies within the locality (state). Assumes\nthat the location state is stored …\n"],["country","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-country","()",""],["country=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-country-3D","(val)",""],["county","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-county","()",""],["county=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-county-3D","(val)",""],["do_initialize","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-do_initialize","()","<p>perform any initialization needed.\n"],["format","Locuser::AddressFormatter","Locuser/AddressFormatter.html#method-i-format","(hsh)","<p>perform address formatting using the given hash. Expects that the hash will\ncontain Strings hashed by …\n"],["full_address","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-full_address","()","<p>get the formatted street address. @return [String] address as one line\n"],["get_entity_type","Locuser::AddressedLocation","Locuser/AddressedLocation.html#method-i-get_entity_type","()","<p>Return the entity type; for taxonomy hierarchy @return [String] this entity\ntype\n"],["get_entity_type","Locuser::City","Locuser/City.html#method-i-get_entity_type","()","<p>Return the entity type (city); for taxonomy hierarchy @return [String] this\nentity type (citys)\n"],["get_entity_type","Locuser::Country","Locuser/Country.html#method-i-get_entity_type","()","<p>Return the entity type (country); for taxonomy hierarchy @return [String]\nthis entity type (country) …\n"],["get_entity_type","Locuser::County","Locuser/County.html#method-i-get_entity_type","()","<p>Return the entity type (state); for taxonomy hierarchy @return [String]\nthis entity type (state)\n"],["get_entity_type","Locuser::Locality","Locuser/Locality.html#method-i-get_entity_type","()","<p>set the entity type (each subclass should override)\n"],["get_entity_type","Locuser::State","Locuser/State.html#method-i-get_entity_type","()","<p>Return the entity type (state); for taxonomy hierarchy @return [String]\nthis entity type (state)\n"],["includetypeinname?","Locuser::County","Locuser/County.html#method-i-includetypeinname-3F","()",""],["includetypeinname?","Locuser::Locality","Locuser/Locality.html#method-i-includetypeinname-3F","()","<p>include type in the name of this place (i.e. &#39;Washington state&#39;)\n"],["latitude","Locuser::Location","Locuser/Location.html#method-i-latitude","()","<p>access the latitude (Geocoder gem tends to store these backwards.) @return\n[Float] the latitude\n"],["longitude","Locuser::Location","Locuser/Location.html#method-i-longitude","()","<p>access the longitude (Geocoder gem tends to store these backwards.) @return\n[Float] the longitude\n"],["new","Locuser::AddressFormatter","Locuser/AddressFormatter.html#method-c-new","(use_country = false)",""],["new","Locuser::Configuration","Locuser/Configuration.html#method-c-new","()","<p>initialize\n"],["primary_key","Locuser::Locality","Locuser/Locality.html#method-c-primary_key","()","<p>field :name, type: String         # name of the locality field\n:description, type: String  # description …\n"],["reset","Locuser::Configuration","Locuser/Configuration.html#method-c-reset","()",""],["set_address","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-set_address","(h, val)","<p>set a particular address component. Generally :street1, :street2, :city,\n:state, :zip, :country are supported. …\n"],["state","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-state","()",""],["state=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-state-3D","(val)",""],["street1","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-street1","()","<p>accessors for address components @return [String] component from address,\nor nil if not present\n"],["street1=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-street1-3D","(val)","<p>setters for address components (hides the hash interface) @return [String]\nreturns the hash that was …\n"],["street2","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-street2","()",""],["street2=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-street2-3D","(val)",""],["typeifiedname","Locuser::Locality","Locuser/Locality.html#method-i-typeifiedname","()","<p>typeify name w entity (i.e. &#39;Washington state&#39; vs.\n&#39;Seattle&#39;). behavior is modified by …\n"],["use_country","Locuser::AddressFormatter","Locuser/AddressFormatter.html#method-i-use_country","()","<p>get the use_country flag @return [Boolean] the value of the flag\n"],["use_country=","Locuser::AddressFormatter","Locuser/AddressFormatter.html#method-i-use_country-3D","(val)","<p>set the use_country flag @param [Boolean] val new value\n"],["valid_parent_types","Locuser::AddressedLocation","Locuser/AddressedLocation.html#method-i-valid_parent_types","()","<p>Valid parent types to support taxonomy hierarchy.  Addressed location can\nlive anywhere. Really should …\n"],["valid_parent_types","Locuser::City","Locuser/City.html#method-i-valid_parent_types","()","<p>Valid parent types to support taxonomy hierarchy. @return [String] valid\nparent\n"],["valid_parent_types","Locuser::Country","Locuser/Country.html#method-i-valid_parent_types","()","<p>Valid parent types (planet is a bit of a joke); engine doesn&#39;t\ncurrently support anything greater …\n"],["valid_parent_types","Locuser::County","Locuser/County.html#method-i-valid_parent_types","()","<p>Valid parent types to support taxonomy hierarchy. @return [String] valid\nparent\n"],["valid_parent_types","Locuser::State","Locuser/State.html#method-i-valid_parent_types","()","<p>Valid parent types to support taxonomy hierarchy. @return [String] valid\nparent\n"],["zip","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-zip","()",""],["zip=","Locuser::StreetAddress","Locuser/StreetAddress.html#method-i-zip-3D","(val)",""],["README","","README_rdoc.html","","<p>Locuser\n<p>This project rocks and uses MIT-LICENSE.\n"]]}}